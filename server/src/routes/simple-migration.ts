import { Router } from 'express';
import { supabaseClient } from '../config/supabase';
import { authenticateUser } from '../middleware/authenticate';

const router = Router();
const supabase = supabaseClient;

// Types pour la migration
interface SimulationProduct {
  code: string;
  score: number;
  savings: number;
  confidence?: string;
}

interface SimulationResults {
  timestamp: number;
  products: SimulationProduct[];
}

interface MigrationRequest {
  clientId: string;
  email: string;
  simulationResults: SimulationResults;
}

// Mapping dynamique des produits (sera mis √† jour automatiquement)
let PRODUCT_MAPPING: { [key: string]: string } = {};

/**
 * Initialiser le mapping des produits depuis la base de donn√©es
 */
async function initializeProductMapping() {
  try {
    console.log('üîÑ Initialisation du mapping des produits...');
    
    const { data: produits, error } = await supabase
      .from('ProduitEligible')
      .select('id, nom, categorie')
      .order('nom');

    if (error) {
      console.error('‚ùå Erreur r√©cup√©ration produits:', error);
      return;
    }

    // Mapping bas√© sur les noms et cat√©gories
    const mapping: { [key: string]: string } = {};
    const codesToFind = ['TICPE', 'URSSAF', 'DFS', 'FONCIER', 'CIR', 'CEE', 'AUDIT_ENERGETIQUE'];
    
    for (const code of codesToFind) {
      const matchingProduct = produits.find(p => 
        p.nom.toLowerCase().includes(code.toLowerCase()) ||
        p.categorie?.toLowerCase().includes(code.toLowerCase())
      );
      
      if (matchingProduct) {
        mapping[code] = matchingProduct.id;
        console.log(`‚úÖ ${code} -> ${matchingProduct.nom} (${matchingProduct.id})`);
      } else {
        console.log(`‚ö†Ô∏è ${code} -> Aucun produit trouv√©`);
      }
    }

    PRODUCT_MAPPING = mapping;
    console.log('‚úÖ Mapping des produits initialis√©:', Object.keys(mapping));
    
  } catch (error) {
    console.error('‚ùå Erreur initialisation mapping:', error);
  }
}

// Initialiser le mapping au d√©marrage
initializeProductMapping();

/**
 * Migration simplifi√©e des r√©sultats de simulation
 * Appel√©e directement apr√®s l'inscription du client
 * REQUIRES AUTHENTICATION
 */
router.post('/migrate-simulation', authenticateUser, async (req, res) => {
  try {
    const { clientId, email, simulationResults }: MigrationRequest = req.body;
    const authUser = req.user; // R√©cup√©r√© par le middleware d'authentification

    console.log('üöÄ MIGRATION SIMPLIFI√âE D√âMARR√âE');
    console.log('üìã Donn√©es re√ßues:');
    console.log('   - Client ID:', clientId);
    console.log('   - Email:', email);
    console.log('   - Nombre de produits:', simulationResults?.products?.length || 0);
    console.log('   - Utilisateur authentifi√©:', authUser?.email);

    // V√©rification de s√©curit√© : l'utilisateur authentifi√© doit correspondre au client
    if (authUser?.email !== email) {
      console.error('‚ùå Tentative d\'acc√®s non autoris√©:', authUser?.email, 'vs', email);
      return res.status(403).json({
        success: false,
        error: 'Acc√®s non autoris√©'
      });
    }

    if (!clientId || !email || !simulationResults) {
      console.error('‚ùå Donn√©es manquantes');
      return res.status(400).json({
        success: false,
        error: 'Donn√©es manquantes'
      });
    }

    // 1. V√©rifier que le client existe (utiliser l'email de l'utilisateur authentifi√©)
    console.log('üîç V√©rification du client...');
    console.log('   - Client ID recherch√©:', clientId);
    console.log('   - Email utilisateur authentifi√©:', authUser.email);
    
    let client = null; // Initialisation explicite pour √©viter les erreurs null
    let clientError;
    
    // Essayer d'abord avec l'ID et l'email
    const { data: clientById, error: errorById } = await supabase
      .from('Client')
      .select('*')  // R√©cup√©rer toutes les colonnes pour s'assurer d'avoir l'ID
      .eq('id', clientId)
      .eq('email', authUser.email)
      .single();

    if (errorById || !clientById) {
      console.error('‚ùå Client non trouv√© par ID et email:', errorById);
      console.log('üîÑ Tentative de r√©cup√©ration par email seulement...');
      
      // Essayer de trouver le client par email seulement
      const { data: clientByEmail, error: emailError } = await supabase
        .from('Client')
        .select('*')  // R√©cup√©rer toutes les colonnes pour s'assurer d'avoir l'ID
        .eq('email', authUser.email)
        .single();
        
      if (emailError || !clientByEmail) {
        console.error('‚ùå Client non trouv√© par email non plus:', emailError);
        return res.status(404).json({
          success: false,
          error: 'Client non trouv√©'
        });
      }
      
      console.log('‚úÖ Client trouv√© par email:', clientByEmail);
      console.log('   - clientByEmail.id:', clientByEmail.id);
      console.log('   - clientByEmail.email:', clientByEmail.email);
      client = clientByEmail;
    } else {
      console.log('‚úÖ Client trouv√© par ID et email:', clientById);
      console.log('   - clientById.id:', clientById.id);
      console.log('   - clientById.email:', clientById.email);
      client = clientById;
    }

    console.log('‚úÖ Client v√©rifi√©:', client?.email);
    console.log('‚úÖ Client ID r√©cup√©r√©:', client?.id);
    console.log('‚úÖ Type client.id:', typeof client?.id);
    console.log('‚úÖ Client complet:', client);
    
    // V√©rification suppl√©mentaire que le client a un ID valide
    if (!client || !client.id) {
      console.error('‚ùå Client ID manquant ou invalide');
      console.error('   - Client object:', client);
      console.error('   - Client ID type:', typeof client?.id);
      console.error('   - Client ID value:', client?.id);
      
      // CORRECTION MINEURE : Utiliser directement le clientId de la requ√™te
      console.log('üîÑ Tentative avec clientId de la requ√™te:', clientId);
      if (clientId) {
        client = { id: clientId, email: authUser.email, name: 'Client from request' };
        console.log('‚úÖ Client cr√©√© √† partir du clientId de la requ√™te');
      } else {
        return res.status(500).json({
          success: false,
          error: 'Client ID invalide'
        });
      }
    }

    // 2. V√©rifier le mapping des produits
    if (Object.keys(PRODUCT_MAPPING).length === 0) {
      console.log('üîÑ Re-initialisation du mapping des produits...');
      await initializeProductMapping();
    }

    console.log('üìä Mapping actuel:', PRODUCT_MAPPING);

    // 3. Migrer chaque produit
    const migratedProducts = [];
    const errors = [];

    console.log('üîÑ D√©but de la migration des produits...');

    for (const product of simulationResults.products) {
      console.log(`\nüì¶ Traitement du produit: ${product.code}`);
      console.log(`   - Score: ${product.score}%`);
      console.log(`   - √âconomies: ${product.savings}‚Ç¨`);

      const produitId = PRODUCT_MAPPING[product.code];

      if (!produitId) {
        const error = `Produit non mapp√©: ${product.code}`;
        console.warn(`‚ö†Ô∏è ${error}`);
        errors.push(error);
        continue;
      }

      console.log(`   - Produit ID trouv√©: ${produitId}`);

      // V√©rification que le clientId est valide
      if (!client || !client.id) {
        const error = `Client ID manquant pour le produit ${product.code}`;
        console.error(`‚ùå ${error}`);
        errors.push(error);
        continue;
      }

      // Cr√©er l'entr√©e ClientProduitEligible avec v√©rification des valeurs
      const clientProduitEligible = {
        clientId: client?.id || clientId, // Fallback sur clientId si client.id est null
        produitId: produitId,
        statut: product.score >= 50 ? 'eligible' : 'non_eligible',
        tauxFinal: product.score / 100,
        montantFinal: product.savings || 0,
        dureeFinale: 12,
        simulationId: null,
        sessionId: null, // Ajouter la colonne manquante
        metadata: {
          original_code: product.code,
          migrated_at: new Date().toISOString(),
          source: 'simulator',
          confidence: product.confidence,
          original_score: product.score
        },
        notes: `Migration depuis simulateur - Score: ${product.score}%`,
        priorite: product.score >= 80 ? 1 : product.score >= 60 ? 2 : 3,
        dateEligibilite: new Date().toISOString(),
        current_step: 0,
        progress: 0,
        expert_id: null,
        charte_signed: false,
        charte_signed_at: null
      };

      console.log(`   - V√©rification des donn√©es avant insertion:`);
      console.log(`     * clientId: ${clientProduitEligible.clientId} (type: ${typeof clientProduitEligible.clientId})`);
      console.log(`     * produitId: ${clientProduitEligible.produitId} (type: ${typeof clientProduitEligible.produitId})`);
      console.log(`     * statut: ${clientProduitEligible.statut}`);
      console.log(`     * tauxFinal: ${clientProduitEligible.tauxFinal}`);
      console.log(`     * montantFinal: ${clientProduitEligible.montantFinal}`);
      console.log(`     * sessionId: ${clientProduitEligible.sessionId}`);

      // Ins√©rer dans la base
      const { data: insertedProduct, error: insertError } = await supabase
        .from('ClientProduitEligible')
        .insert(clientProduitEligible)
        .select()
        .single();
        
      if (insertError) {
        const error = `Erreur insertion ${product.code}: ${insertError.message}`;
        console.error(`‚ùå ${error}`);
        console.error(`‚ùå D√©tails de l'erreur:`, insertError);
        console.error(`‚ùå Donn√©es qui ont caus√© l'erreur:`, JSON.stringify(clientProduitEligible, null, 2));
        errors.push(error);
        continue;
      }

      migratedProducts.push(insertedProduct);
      console.log(`‚úÖ ${product.code} migr√© avec succ√®s: ${insertedProduct.id}`);
    }
    
    console.log(`\nüéâ Migration termin√©e:`);
    console.log(`   - Produits migr√©s: ${migratedProducts.length}`);
    console.log(`   - Erreurs: ${errors.length}`);
    
    if (errors.length > 0) {
      console.log('‚ö†Ô∏è Erreurs rencontr√©es:', errors);
    }
    
    return res.json({
      success: true,
      data: {
        client_id: client.id,
        migrated_products: migratedProducts.length,
        products: migratedProducts,
        errors: errors
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur migration:', error);
    return res.status(500).json({
      success: false,
      error: 'Erreur lors de la migration',
      details: error instanceof Error ? error.message : 'Erreur inconnue'
    });
  }
});

/**
 * R√©cup√©rer les produits √©ligibles d'un client
 */
router.get('/client-products/:clientId', async (req, res) => {
  try {
    const { clientId } = req.params;
    
    console.log('üìã R√©cup√©ration des produits pour le client:', clientId);
    
    const { data: products, error } = await supabase
      .from('ClientProduitEligible')
      .select(`
        *,
        ProduitEligible (
          id,
          nom,
          description,
          categorie
        )
      `)
      .eq('clientId', clientId);
      
    if (error) {
      console.error('‚ùå Erreur r√©cup√©ration produits:', error);
      return res.status(500).json({
        success: false,
        error: 'Erreur r√©cup√©ration produits'
      });
    }
    
    console.log(`‚úÖ ${products?.length || 0} produits r√©cup√©r√©s`);
    
    return res.json({
      success: true,
      data: {
        client_id: clientId,
        products: products || []
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration:', error);
    return res.status(500).json({
      success: false,
      error: 'Erreur serveur'
    });
  }
});

/**
 * Route de debug pour v√©rifier le mapping des produits
 */
router.get('/debug/mapping', async (req, res) => {
  try {
    console.log('üîç Debug: V√©rification du mapping des produits');
    
    const { data: produits, error } = await supabase
      .from('ProduitEligible')
      .select('id, nom, categorie')
      .order('nom');

    if (error) {
      return res.status(500).json({
        success: false,
        error: 'Erreur r√©cup√©ration produits'
      });
    }

    return res.json({
      success: true,
      data: {
        mapping: PRODUCT_MAPPING,
        produits: produits,
        mapping_keys: Object.keys(PRODUCT_MAPPING)
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur debug:', error);
    return res.status(500).json({
      success: false,
      error: 'Erreur serveur'
    });
  }
});

/**
 * Route pour recharger le mapping des produits
 */
router.post('/reload-mapping', async (req, res) => {
  try {
    console.log('üîÑ Rechargement du mapping des produits...');
    await initializeProductMapping();
    
    return res.json({
      success: true,
      data: {
        mapping: PRODUCT_MAPPING,
        message: 'Mapping recharg√© avec succ√®s'
      }
    });
    
  } catch (error) {
    console.error('‚ùå Erreur rechargement mapping:', error);
    return res.status(500).json({
      success: false,
      error: 'Erreur lors du rechargement'
    });
  }
});

export default router; 