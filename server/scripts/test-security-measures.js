#!/usr/bin/env node

/**
 * Script de Test des Mesures de S√©curit√©
 * Valide l'impl√©mentation des mesures ISO 27001
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class SecurityMeasuresTester {
    constructor() {
        this.results = {
            totalTests: 0,
            passedTests: 0,
            failedTests: 0,
            details: []
        };
    }

    async runAllTests() {
        console.log('üîç Test des Mesures de S√©curit√© ISO 27001\n');
        
        await this.testEncryption();
        await this.testBackupSystem();
        await this.testIncidentManagement();
        await this.testDocumentation();
        await this.testOperationalProcedures();
        
        this.generateReport();
    }

    async testEncryption() {
        console.log('üîê Test du Syst√®me de Chiffrement (A.10.1)...');
        
        try {
            // Test de g√©n√©ration de cl√©
            const key = crypto.randomBytes(32).toString('hex');
            this.addTest('G√©n√©ration de cl√© s√©curis√©e', key.length === 64, 'Cl√© 256 bits g√©n√©r√©e');
            
            // Test de chiffrement/d√©chiffrement
            const testData = 'Donn√©es sensibles de test';
            const iv = crypto.randomBytes(16);
            const cipher = crypto.createCipheriv('aes-256-gcm', Buffer.from(key, 'hex'), iv);
            cipher.setAAD(Buffer.from('profitum-aad', 'utf8'));
            
            let encrypted = cipher.update(testData, 'utf8', 'hex');
            encrypted += cipher.final('hex');
            const tag = cipher.getAuthTag();
            
            const decipher = crypto.createDecipheriv('aes-256-gcm', Buffer.from(key, 'hex'), iv);
            decipher.setAAD(Buffer.from('profitum-aad', 'utf8'));
            decipher.setAuthTag(tag);
            
            let decrypted = decipher.update(encrypted, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            
            this.addTest('Chiffrement/d√©chiffrement AES-256-GCM', decrypted === testData, 'Chiffrement fonctionnel');
            
            // Test de hash de mot de passe
            const password = 'MotDePasseComplexe123!';
            const salt = crypto.randomBytes(16).toString('hex');
            const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
            
            this.addTest('Hash de mot de passe PBKDF2', hash.length === 128, 'Hash s√©curis√© g√©n√©r√©');
            
        } catch (error) {
            this.addTest('Syst√®me de chiffrement', false, `Erreur: ${error.message}`);
        }
    }

    async testBackupSystem() {
        console.log('üíæ Test du Syst√®me de Sauvegarde (A.12.3)...');
        
        try {
            // Test de cr√©ation du r√©pertoire de sauvegarde
            const backupPath = './backups/';
            if (!fs.existsSync(backupPath)) {
                fs.mkdirSync(backupPath, { recursive: true });
            }
            
            this.addTest('R√©pertoire de sauvegarde', fs.existsSync(backupPath), 'R√©pertoire cr√©√©');
            
            // Test de cr√©ation d'une sauvegarde de test
            const testBackup = {
                id: `test-${Date.now()}`,
                timestamp: new Date().toISOString(),
                data: 'Donn√©es de test pour sauvegarde',
                checksum: crypto.createHash('sha256').update('Donn√©es de test pour sauvegarde').digest('hex')
            };
            
            const backupFile = path.join(backupPath, `test-backup-${Date.now()}.json`);
            fs.writeFileSync(backupFile, JSON.stringify(testBackup, null, 2));
            
            this.addTest('Cr√©ation de sauvegarde', fs.existsSync(backupFile), 'Fichier de sauvegarde cr√©√©');
            
            // Test de v√©rification d'int√©grit√©
            const loadedBackup = JSON.parse(fs.readFileSync(backupFile, 'utf8'));
            const expectedChecksum = crypto.createHash('sha256').update(loadedBackup.data).digest('hex');
            
            this.addTest('V√©rification d\'int√©grit√©', loadedBackup.checksum === expectedChecksum, 'Int√©grit√© v√©rifi√©e');
            
            // Nettoyage
            fs.unlinkSync(backupFile);
            
        } catch (error) {
            this.addTest('Syst√®me de sauvegarde', false, `Erreur: ${error.message}`);
        }
    }

    async testIncidentManagement() {
        console.log('üö® Test du Syst√®me de Gestion d\'Incidents (A.16.1)...');
        
        try {
            // Test de cr√©ation du r√©pertoire d'incidents
            const incidentPath = './incidents/';
            if (!fs.existsSync(incidentPath)) {
                fs.mkdirSync(incidentPath, { recursive: true });
            }
            
            this.addTest('R√©pertoire d\'incidents', fs.existsSync(incidentPath), 'R√©pertoire cr√©√©');
            
            // Test de cr√©ation d'un incident de test
            const testIncident = {
                id: `INC-TEST-${Date.now()}`,
                title: 'Test d\'incident de s√©curit√©',
                description: 'Incident de test pour validation',
                type: 'security_breach',
                severity: 'medium',
                status: 'open',
                reportedAt: new Date().toISOString(),
                reportedBy: 'test-system',
                impact: 'Test uniquement',
                tags: ['test', 'security'],
                evidence: [],
                notifications: []
            };
            
            const incidentFile = path.join(incidentPath, 'test-incident.json');
            fs.writeFileSync(incidentFile, JSON.stringify(testIncident, null, 2));
            
            this.addTest('Cr√©ation d\'incident', fs.existsSync(incidentFile), 'Incident cr√©√©');
            
            // Test de mise √† jour de statut
            const loadedIncident = JSON.parse(fs.readFileSync(incidentFile, 'utf8'));
            loadedIncident.status = 'investigating';
            loadedIncident.investigationStartedAt = new Date().toISOString();
            
            fs.writeFileSync(incidentFile, JSON.stringify(loadedIncident, null, 2));
            
            this.addTest('Mise √† jour de statut', fs.existsSync(incidentFile), 'Statut mis √† jour');
            
            // Nettoyage
            fs.unlinkSync(incidentFile);
            
        } catch (error) {
            this.addTest('Syst√®me de gestion d\'incidents', false, `Erreur: ${error.message}`);
        }
    }

    async testDocumentation() {
        console.log('üìã Test de la Documentation (A.5.1)...');
        
        try {
            // Test de la politique de s√©curit√©
            const securityPolicyPath = './docs/SECURITY_POLICY.md';
            this.addTest('Politique de s√©curit√©', fs.existsSync(securityPolicyPath), 'Document trouv√©');
            
            if (fs.existsSync(securityPolicyPath)) {
                const content = fs.readFileSync(securityPolicyPath, 'utf8');
                this.addTest('Contenu politique', content.length > 1000, 'Document complet');
                this.addTest('Sections requises', 
                    content.includes('A.9') && content.includes('A.10') && content.includes('A.12') && content.includes('A.16'),
                    'Sections ISO 27001 pr√©sentes'
                );
            }
            
            // Test des proc√©dures op√©rationnelles
            const proceduresPath = './docs/OPERATIONAL_PROCEDURES.md';
            this.addTest('Proc√©dures op√©rationnelles', fs.existsSync(proceduresPath), 'Document trouv√©');
            
            if (fs.existsSync(proceduresPath)) {
                const content = fs.readFileSync(proceduresPath, 'utf8');
                this.addTest('Contenu proc√©dures', content.length > 1000, 'Document complet');
                this.addTest('Proc√©dures critiques', 
                    content.includes('D√©ploiement') && content.includes('Maintenance') && content.includes('Incident'),
                    'Proc√©dures critiques pr√©sentes'
                );
            }
            
        } catch (error) {
            this.addTest('Documentation', false, `Erreur: ${error.message}`);
        }
    }

    async testOperationalProcedures() {
        console.log('‚öôÔ∏è Test des Proc√©dures Op√©rationnelles (A.12.1)...');
        
        try {
            // Test de la structure des r√©pertoires
            const requiredDirs = ['./lib', './docs', './backups', './incidents'];
            
            for (const dir of requiredDirs) {
                this.addTest(`R√©pertoire ${dir}`, fs.existsSync(dir), 'R√©pertoire pr√©sent');
            }
            
            // Test des fichiers de configuration
            const configFiles = ['./package.json', './tsconfig.json'];
            
            for (const file of configFiles) {
                this.addTest(`Fichier de config ${file}`, fs.existsSync(file), 'Fichier pr√©sent');
            }
            
            // Test des modules de s√©curit√©
            const securityModules = ['./lib/encryption.ts', './lib/backup.ts', './lib/incident-management.ts'];
            
            for (const module of securityModules) {
                this.addTest(`Module s√©curit√© ${module}`, fs.existsSync(module), 'Module pr√©sent');
            }
            
        } catch (error) {
            this.addTest('Proc√©dures op√©rationnelles', false, `Erreur: ${error.message}`);
        }
    }

    addTest(name, passed, details) {
        this.results.totalTests++;
        
        if (passed) {
            this.results.passedTests++;
            console.log(`  ‚úÖ ${name}`);
        } else {
            this.results.failedTests++;
            console.log(`  ‚ùå ${name}: ${details}`);
        }
        
        this.results.details.push({
            name,
            passed,
            details
        });
    }

    generateReport() {
        console.log('\nüìä RAPPORT DE TEST DES MESURES DE S√âCURIT√â');
        console.log('=' .repeat(50));
        
        const successRate = Math.round((this.results.passedTests / this.results.totalTests) * 100);
        
        console.log(`\nüéØ Taux de r√©ussite: ${successRate}%`);
        console.log(`üìà Tests r√©ussis: ${this.results.passedTests}/${this.results.totalTests}`);
        
        if (this.results.failedTests > 0) {
            console.log('\n‚ùå Tests √©chou√©s:');
            this.results.details
                .filter(test => !test.passed)
                .forEach(test => {
                    console.log(`  - ${test.name}: ${test.details}`);
                });
        }
        
        // √âvaluation de la conformit√©
        let complianceLevel = '';
        if (successRate >= 90) {
            complianceLevel = 'üü¢ EXCELLENT - Pr√™t pour certification';
        } else if (successRate >= 75) {
            complianceLevel = 'üü° BON - Am√©liorations mineures n√©cessaires';
        } else if (successRate >= 60) {
            complianceLevel = 'üü† MOYEN - Travail significatif requis';
        } else {
            complianceLevel = 'üî¥ CRITIQUE - Travail majeur requis';
        }
        
        console.log(`\n${complianceLevel}`);
        
        // Recommandations
        if (successRate < 90) {
            console.log('\nüö® Recommandations:');
            if (this.results.failedTests > 0) {
                console.log('  1. Corriger les tests √©chou√©s');
            }
            console.log('  2. Compl√©ter la documentation manquante');
            console.log('  3. Tester en environnement de production');
            console.log('  4. Former l\'√©quipe aux nouvelles proc√©dures');
        }
        
        // Sauvegarde du rapport
        this.saveReport();
    }

    saveReport() {
        const report = {
            timestamp: new Date().toISOString(),
            successRate: Math.round((this.results.passedTests / this.results.totalTests) * 100),
            totalTests: this.results.totalTests,
            passedTests: this.results.passedTests,
            failedTests: this.results.failedTests,
            details: this.results.details
        };
        
        const reportPath = './security-test-report.json';
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        
        console.log(`\nüíæ Rapport sauvegard√©: ${reportPath}`);
    }
}

async function main() {
    const tester = new SecurityMeasuresTester();
    await tester.runAllTests();
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = SecurityMeasuresTester;
