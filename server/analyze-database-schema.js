const { createClient } = require('@supabase/supabase-js');

// Configuration Supabase
const supabaseUrl = process.env.SUPABASE_URL || 'https://your-project.supabase.co';
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || 'your-service-role-key';

const supabase = createClient(supabaseUrl, supabaseServiceKey);

async function analyzeDatabaseSchema() {
  console.log('üîç Analyse compl√®te du sch√©ma de la base de donn√©es...\n');

  try {
    // 1. R√©cup√©rer toutes les tables
    console.log('1. R√©cup√©ration de toutes les tables...');
    
    const { data: tables, error: tablesError } = await supabase
      .from('information_schema.tables')
      .select('table_name, table_type')
      .eq('table_schema', 'public')
      .order('table_name');

    if (tablesError) {
      console.error('‚ùå Erreur r√©cup√©ration tables:', tablesError);
      return;
    }

    console.log(`‚úÖ ${tables.length} tables trouv√©es\n`);

    // 2. Analyser chaque table en d√©tail
    const schemaAnalysis = {};

    for (const table of tables) {
      const tableName = table.table_name;
      console.log(`üìã Analyse de la table: ${tableName}`);
      
      try {
        // R√©cup√©rer les colonnes
        const { data: columns, error: columnsError } = await supabase
          .from('information_schema.columns')
          .select(`
            column_name,
            data_type,
            is_nullable,
            column_default,
            character_maximum_length,
            numeric_precision,
            numeric_scale,
            ordinal_position
          `)
          .eq('table_schema', 'public')
          .eq('table_name', tableName)
          .order('ordinal_position');

        if (columnsError) {
          console.error(`‚ùå Erreur colonnes ${tableName}:`, columnsError);
          continue;
        }

        // R√©cup√©rer les contraintes
        const { data: constraints, error: constraintsError } = await supabase
          .from('information_schema.table_constraints')
          .select(`
            constraint_name,
            constraint_type
          `)
          .eq('table_schema', 'public')
          .eq('table_name', tableName);

        // R√©cup√©rer les cl√©s √©trang√®res
        const { data: foreignKeys, error: foreignKeysError } = await supabase
          .from('information_schema.key_column_usage')
          .select(`
            constraint_name,
            column_name,
            referenced_table_name,
            referenced_column_name
          `)
          .eq('table_schema', 'public')
          .eq('table_name', tableName)
          .not('referenced_table_name', 'is', null);

        // R√©cup√©rer les index
        const { data: indexes, error: indexesError } = await supabase
          .rpc('get_table_indexes', { table_name: tableName })
          .catch(() => ({ data: null, error: null })); // Ignorer si la fonction n'existe pas

        // Compter les lignes
        const { count: rowCount, error: countError } = await supabase
          .from(tableName)
          .select('*', { count: 'exact', head: true })
          .catch(() => ({ count: null, error: null }));

        // Analyser la structure
        const tableAnalysis = {
          name: tableName,
          type: table.table_type,
          columns: columns.map(col => ({
            name: col.column_name,
            type: col.data_type,
            nullable: col.is_nullable === 'YES',
            default: col.column_default,
            maxLength: col.character_maximum_length,
            precision: col.numeric_precision,
            scale: col.numeric_scale,
            position: col.ordinal_position
          })),
          constraints: constraints?.map(c => ({
            name: c.constraint_name,
            type: c.constraint_type
          })) || [],
          foreignKeys: foreignKeys?.map(fk => ({
            column: fk.column_name,
            references: `${fk.referenced_table_name}.${fk.referenced_column_name}`,
            constraint: fk.constraint_name
          })) || [],
          indexes: indexes || [],
          rowCount: rowCount || 0,
          primaryKey: columns.find(col => 
            constraints?.some(c => 
              c.constraint_type === 'PRIMARY KEY' && 
              c.constraint_name.includes(col.column_name)
            )
          )?.column_name,
          hasTimestamps: columns.some(col => 
            ['created_at', 'updated_at', 'timestamp'].includes(col.column_name)
          ),
          hasSoftDelete: columns.some(col => 
            ['deleted_at', 'is_deleted', 'active'].includes(col.column_name)
          )
        };

        schemaAnalysis[tableName] = tableAnalysis;

        console.log(`   ‚úÖ ${columns.length} colonnes, ${rowCount || 0} lignes`);

      } catch (error) {
        console.error(`‚ùå Erreur analyse ${tableName}:`, error.message);
        schemaAnalysis[tableName] = { name: tableName, error: error.message };
      }
    }

    // 3. G√©n√©rer le rapport complet
    console.log('\nüìä G√©n√©ration du rapport complet...');
    
    const report = {
      generatedAt: new Date().toISOString(),
      totalTables: Object.keys(schemaAnalysis).length,
      tables: schemaAnalysis,
      summary: {
        tablesWithTimestamps: Object.values(schemaAnalysis).filter(t => t.hasTimestamps).length,
        tablesWithSoftDelete: Object.values(schemaAnalysis).filter(t => t.hasSoftDelete).length,
        totalColumns: Object.values(schemaAnalysis).reduce((sum, t) => sum + (t.columns?.length || 0), 0),
        totalRows: Object.values(schemaAnalysis).reduce((sum, t) => sum + (t.rowCount || 0), 0)
      }
    };

    // 4. Sauvegarder le rapport
    const fs = require('fs');
    const reportPath = 'database-schema-analysis.json';
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
    
    console.log(`‚úÖ Rapport sauvegard√©: ${reportPath}`);

    // 5. Afficher le r√©sum√©
    console.log('\nüìã R√âSUM√â DE L\'ANALYSE:');
    console.log(`   üìä Tables analys√©es: ${report.totalTables}`);
    console.log(`   üìù Colonnes totales: ${report.summary.totalColumns}`);
    console.log(`   üìà Lignes totales: ${report.summary.totalRows}`);
    console.log(`   ‚è∞ Tables avec timestamps: ${report.summary.tablesWithTimestamps}`);
    console.log(`   üóëÔ∏è Tables avec soft delete: ${report.summary.tablesWithSoftDelete}`);

    // 6. Afficher les tables par cat√©gorie
    console.log('\nüè∑Ô∏è CAT√âGORISATION DES TABLES:');
    
    const categories = {
      'Utilisateurs & Auth': ['Client', 'Expert', 'Admin', 'User', 'Profile'],
      'Produits & Services': ['ProduitEligible', 'ClientProduitEligible', 'ChartesProduits'],
      'Assignations & Relations': ['ExpertAssignment', 'ExpertSpecialization'],
      'Communication': ['message', 'Conversation', 'Message'],
      'Notifications': ['ExpertNotifications', 'Notification'],
      'Audit & Suivi': ['Audit', 'AuditProgress', 'AuditStep'],
      'Documents': ['Document', 'Documentation'],
      'Syst√®me': ['PerformanceMetrics', 'ErrorMetrics', 'SystemMetrics', 'Alerts']
    };

    for (const [category, tableNames] of Object.entries(categories)) {
      const tablesInCategory = Object.keys(schemaAnalysis).filter(name => 
        tableNames.some(pattern => name.includes(pattern))
      );
      
      if (tablesInCategory.length > 0) {
        console.log(`\n   ${category}:`);
        tablesInCategory.forEach(tableName => {
          const table = schemaAnalysis[tableName];
          console.log(`     - ${tableName} (${table.columns?.length || 0} colonnes, ${table.rowCount || 0} lignes)`);
        });
      }
    }

    // 7. Tables non cat√©goris√©es
    const categorizedTables = Object.values(categories).flat();
    const uncategorizedTables = Object.keys(schemaAnalysis).filter(name => 
      !categorizedTables.some(pattern => name.includes(pattern))
    );

    if (uncategorizedTables.length > 0) {
      console.log('\n   üîç Tables non cat√©goris√©es:');
      uncategorizedTables.forEach(tableName => {
        const table = schemaAnalysis[tableName];
        console.log(`     - ${tableName} (${table.columns?.length || 0} colonnes, ${table.rowCount || 0} lignes)`);
      });
    }

    // 8. G√©n√©rer la documentation Markdown
    generateMarkdownDocumentation(report);

    console.log('\nüéâ Analyse termin√©e avec succ√®s !');
    console.log('\nüìÅ Fichiers g√©n√©r√©s:');
    console.log('   - database-schema-analysis.json (donn√©es brutes)');
    console.log('   - DATABASE_SCHEMA_DOCUMENTATION.md (documentation)');

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'analyse:', error);
  }
}

function generateMarkdownDocumentation(report) {
  const fs = require('fs');
  
  let markdown = `# Documentation du Sch√©ma de Base de Donn√©es

**G√©n√©r√© le:** ${new Date(report.generatedAt).toLocaleString('fr-FR')}
**Version:** 1.0
**Base de donn√©es:** Supabase

## üìä Vue d'ensemble

- **Tables totales:** ${report.totalTables}
- **Colonnes totales:** ${report.summary.totalColumns}
- **Lignes totales:** ${report.summary.totalRows}
- **Tables avec timestamps:** ${report.summary.tablesWithTimestamps}
- **Tables avec soft delete:** ${report.summary.tablesWithSoftDelete}

## üèóÔ∏è Structure des Tables

`;

  // Trier les tables par cat√©gorie
  const categories = {
    'Utilisateurs & Authentification': ['Client', 'Expert', 'Admin', 'User', 'Profile'],
    'Produits & Services': ['ProduitEligible', 'ClientProduitEligible', 'ChartesProduits'],
    'Assignations & Relations': ['ExpertAssignment', 'ExpertSpecialization'],
    'Communication': ['message', 'Conversation', 'Message'],
    'Notifications': ['ExpertNotifications', 'Notification'],
    'Audit & Suivi': ['Audit', 'AuditProgress', 'AuditStep'],
    'Documents': ['Document', 'Documentation'],
    'Syst√®me & Monitoring': ['PerformanceMetrics', 'ErrorMetrics', 'SystemMetrics', 'Alerts']
  };

  for (const [category, patterns] of Object.entries(categories)) {
    const tablesInCategory = Object.keys(report.tables).filter(name => 
      patterns.some(pattern => name.includes(pattern))
    );

    if (tablesInCategory.length > 0) {
      markdown += `\n### ${category}\n\n`;
      
      tablesInCategory.forEach(tableName => {
        const table = report.tables[tableName];
        if (table.error) {
          markdown += `#### ${tableName}\n\n*Erreur d'acc√®s: ${table.error}*\n\n`;
          return;
        }

        markdown += `#### ${tableName}\n\n`;
        markdown += `**Type:** ${table.type} | **Lignes:** ${table.rowCount} | **Colonnes:** ${table.columns.length}\n\n`;

        if (table.primaryKey) {
          markdown += `**Cl√© primaire:** \`${table.primaryKey}\`\n\n`;
        }

        if (table.hasTimestamps) {
          markdown += `**Timestamps:** ‚úÖ\n\n`;
        }

        if (table.hasSoftDelete) {
          markdown += `**Soft Delete:** ‚úÖ\n\n`;
        }

        // Colonnes
        markdown += `**Colonnes:**\n\n`;
        markdown += `| Nom | Type | Nullable | D√©faut | Description |\n`;
        markdown += `|-----|------|----------|--------|-------------|\n`;

        table.columns.forEach(col => {
          const type = col.maxLength ? `${col.type}(${col.maxLength})` : 
                      col.precision ? `${col.type}(${col.precision},${col.scale})` : 
                      col.type;
          
          markdown += `| \`${col.name}\` | \`${type}\` | ${col.nullable ? 'Oui' : 'Non'} | ${col.default || '-'} | - |\n`;
        });

        // Cl√©s √©trang√®res
        if (table.foreignKeys.length > 0) {
          markdown += `\n**Cl√©s √©trang√®res:**\n\n`;
          markdown += `| Colonne | R√©f√©rence |\n`;
          markdown += `|---------|-----------|\n`;
          table.foreignKeys.forEach(fk => {
            markdown += `| \`${fk.column}\` | \`${fk.references}\` |\n`;
          });
        }

        markdown += `\n---\n\n`;
      });
    }
  }

  // Tables non cat√©goris√©es
  const categorizedTables = Object.values(categories).flat();
  const uncategorizedTables = Object.keys(report.tables).filter(name => 
    !categorizedTables.some(pattern => name.includes(pattern))
  );

  if (uncategorizedTables.length > 0) {
    markdown += `\n### Tables Non Cat√©goris√©es\n\n`;
    uncategorizedTables.forEach(tableName => {
      const table = report.tables[tableName];
      markdown += `#### ${tableName}\n\n`;
      markdown += `**Type:** ${table.type} | **Lignes:** ${table.rowCount} | **Colonnes:** ${table.columns?.length || 0}\n\n`;
      
      if (table.columns) {
        markdown += `**Colonnes:** ${table.columns.map(col => `\`${col.name}\``).join(', ')}\n\n`;
      }
    });
  }

  markdown += `\n## üìù Notes

- Cette documentation est g√©n√©r√©e automatiquement
- Les descriptions des colonnes doivent √™tre ajout√©es manuellement
- V√©rifiez les contraintes et index selon vos besoins
- Les tables avec timestamps incluent g√©n√©ralement \`created_at\` et \`updated_at\`

## üîÑ Mise √† jour

Pour mettre √† jour cette documentation, ex√©cutez:
\`\`\`bash
node analyze-database-schema.js
\`\`\`
`;

  fs.writeFileSync('DATABASE_SCHEMA_DOCUMENTATION.md', markdown);
  console.log('‚úÖ Documentation Markdown g√©n√©r√©e');
}

// Ex√©cuter l'analyse
analyzeDatabaseSchema(); 