#!/usr/bin/env node

/**
 * üß™ Script de Test Complet - Syst√®me de Simulation
 * 
 * Ce script teste le flux complet:
 * 1. Connexion client
 * 2. Cr√©ation simulation
 * 3. R√©ponses aux questions
 * 4. √âvaluation √©ligibilit√©
 * 5. V√©rification ClientProduitEligible
 * 
 * Usage: node test-simulation-complete.js
 */

import fetch from 'node-fetch';
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

// Configuration
const API_URL = process.env.API_URL || 'http://localhost:3000';
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// Couleurs pour la console
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(emoji, message, color = colors.reset) {
  console.log(`${color}${emoji} ${message}${colors.reset}`);
}

function success(message) {
  log('‚úÖ', message, colors.green);
}

function error(message) {
  log('‚ùå', message, colors.red);
}

function info(message) {
  log('‚ÑπÔ∏è', message, colors.blue);
}

function warning(message) {
  log('‚ö†Ô∏è', message, colors.yellow);
}

// ==============================================================================
// 1. CONNEXION CLIENT
// ==============================================================================

async function loginClient() {
  info('Connexion du client de test...');
  
  try {
    // Utiliser un client existant ou en cr√©er un
    const testEmail = 'test-simulation@profitum.fr';
    const testPassword = 'TestSimulation2025!';
    
    const response = await fetch(`${API_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: testEmail,
        password: testPassword,
        type: 'client'
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      success(`Client connect√©: ${data.user.username}`);
      return {
        token: data.token,
        userId: data.user.id,
        databaseId: data.user.database_id
      };
    } else {
      error(`√âchec connexion: ${data.message}`);
      return null;
    }
  } catch (err) {
    error(`Erreur connexion: ${err.message}`);
    return null;
  }
}

// ==============================================================================
// 2. CR√âATION SIMULATION
// ==============================================================================

async function createSimulation(token, clientId) {
  info('Cr√©ation de la simulation...');
  
  try {
    const response = await fetch(`${API_URL}/api/simulations`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        clientId: clientId,
        statut: 'en_cours'
      })
    });
    
    const data = await response.json();
    
    if (data.success && data.data.simulation) {
      success(`Simulation cr√©√©e: ID ${data.data.simulation.id}`);
      return data.data.simulation.id;
    } else {
      error(`√âchec cr√©ation simulation: ${data.message}`);
      return null;
    }
  } catch (err) {
    error(`Erreur cr√©ation simulation: ${err.message}`);
    return null;
  }
}

// ==============================================================================
// 3. R√âCUP√âRATION DES QUESTIONS
// ==============================================================================

async function getQuestions(token) {
  info('R√©cup√©ration des questions...');
  
  try {
    const response = await fetch(`${API_URL}/api/simulations/questions`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    const data = await response.json();
    
    if (data.success && data.data) {
      success(`${data.data.length} questions r√©cup√©r√©es`);
      return data.data;
    } else {
      error('√âchec r√©cup√©ration questions');
      return [];
    }
  } catch (err) {
    error(`Erreur r√©cup√©ration questions: ${err.message}`);
    return [];
  }
}

// ==============================================================================
// 4. R√âPONSES DE TEST
// ==============================================================================

function generateTestAnswers(questions) {
  info('G√©n√©ration des r√©ponses de test...');
  
  // R√©ponses pour obtenir TICPE, URSSAF, DFS √©ligibles
  const answers = {
    // Secteur d'activit√©: Transport
    1: ['Transport'],
    
    // Chiffre d'affaires: Plus de 100 000‚Ç¨
    2: ['Plus de 500 000‚Ç¨'],
    
    // Contentieux fiscal: Aucun
    3: ['Aucun'],
    
    // Propri√©taire locaux: Non (pour tester Foncier non √©ligible)
    4: ['Non'],
    
    // Factures √©nerg√©tiques: Oui
    5: ['Oui'],
    
    // V√©hicules professionnels: Oui
    6: ['Oui'],
    
    // Type de v√©hicules: Camions > 7,5T
    7: ['Camions de plus de 7,5 tonnes'],
    
    // Nombre d'employ√©s
    8: ['10-50'],
    
    // Cr√©ances impay√©es: Non
    9: ['Non'],
  };
  
  success(`R√©ponses g√©n√©r√©es pour ${Object.keys(answers).length} questions`);
  return answers;
}

// ==============================================================================
// 5. ENVOI DES R√âPONSES
// ==============================================================================

async function saveAnswers(token, simulationId, answers) {
  info('Sauvegarde des r√©ponses...');
  
  try {
    const response = await fetch(`${API_URL}/api/simulations/${simulationId}/answers`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ answers })
    });
    
    const data = await response.json();
    
    if (data.success) {
      success('R√©ponses sauvegard√©es');
      return true;
    } else {
      error(`√âchec sauvegarde r√©ponses: ${data.message}`);
      return false;
    }
  } catch (err) {
    error(`Erreur sauvegarde r√©ponses: ${err.message}`);
    return false;
  }
}

// ==============================================================================
// 6. TERMINER LA SIMULATION
// ==============================================================================

async function completeSimulation(token, simulationId) {
  info('Finalisation de la simulation...');
  
  try {
    const response = await fetch(`${API_URL}/api/simulations/${simulationId}/terminer`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      }
    });
    
    const data = await response.json();
    
    if (data.success) {
      success('Simulation termin√©e et trait√©e');
      return true;
    } else {
      error(`√âchec finalisation: ${data.message}`);
      return false;
    }
  } catch (err) {
    error(`Erreur finalisation: ${err.message}`);
    return false;
  }
}

// ==============================================================================
// 7. V√âRIFICATION DES R√âSULTATS
// ==============================================================================

async function verifyResults(clientId, simulationId) {
  info('V√©rification des ClientProduitEligible cr√©√©s...');
  
  try {
    // Attendre 2 secondes pour laisser le temps au traitement
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const { data: clientProduits, error: cpError } = await supabase
      .from('ClientProduitEligible')
      .select(`
        id,
        statut,
        tauxFinal,
        montantFinal,
        dureeFinale,
        priorite,
        notes,
        metadata,
        ProduitEligible:produitId (
          nom,
          categorie
        )
      `)
      .eq('clientId', clientId)
      .eq('simulationId', simulationId)
      .order('priorite', { ascending: true });
    
    if (cpError) {
      error(`Erreur r√©cup√©ration r√©sultats: ${cpError.message}`);
      return { eligible: [], nonEligible: [] };
    }
    
    const eligible = clientProduits.filter(cp => cp.statut === 'eligible');
    const nonEligible = clientProduits.filter(cp => cp.statut === 'non_eligible');
    
    console.log('\n' + '='.repeat(80));
    log('üìä', 'R√âSULTATS DE LA SIMULATION', colors.bright);
    console.log('='.repeat(80));
    
    console.log(`\n${colors.green}‚úÖ PRODUITS √âLIGIBLES (${eligible.length})${colors.reset}`);
    console.log('-'.repeat(80));
    eligible.forEach((cp, index) => {
      console.log(`\n${index + 1}. ${colors.bright}${cp.ProduitEligible.nom}${colors.reset}`);
      console.log(`   üìà Gain estim√©: ${colors.cyan}${cp.montantFinal?.toLocaleString() || 'N/A'}‚Ç¨${colors.reset}`);
      console.log(`   ‚è±Ô∏è  Dur√©e: ${cp.dureeFinale || 'N/A'} mois`);
      console.log(`   ‚≠ê Priorit√©: ${cp.priorite}`);
      if (cp.metadata?.score) {
        console.log(`   üíØ Score: ${(cp.metadata.score * 100).toFixed(1)}%`);
      }
    });
    
    console.log(`\n${colors.yellow}‚ùå PRODUITS NON √âLIGIBLES (${nonEligible.length})${colors.reset}`);
    console.log('-'.repeat(80));
    nonEligible.forEach((cp, index) => {
      console.log(`${index + 1}. ${cp.ProduitEligible.nom}`);
    });
    
    console.log('\n' + '='.repeat(80));
    
    if (eligible.length > 0) {
      success(`${eligible.length} produits √©ligibles identifi√©s !`);
    } else {
      warning('Aucun produit √©ligible trouv√©');
    }
    
    return { eligible, nonEligible };
    
  } catch (err) {
    error(`Erreur v√©rification r√©sultats: ${err.message}`);
    return { eligible: [], nonEligible: [] };
  }
}

// ==============================================================================
// 8. V√âRIFICATION DE LA SIMULATION DANS LA BDD
// ==============================================================================

async function verifySimulationData(simulationId) {
  info('V√©rification des donn√©es de simulation...');
  
  try {
    const { data: simulation, error } = await supabase
      .from('simulations')
      .select('*')
      .eq('id', simulationId)
      .single();
    
    if (error) {
      error(`Erreur r√©cup√©ration simulation: ${error.message}`);
      return false;
    }
    
    console.log('\nüìã D√©tails de la simulation:');
    console.log(`   ID: ${simulation.id}`);
    console.log(`   Client: ${simulation.client_id}`);
    console.log(`   Status: ${simulation.status}`);
    console.log(`   Cr√©√©e le: ${new Date(simulation.created_at).toLocaleString('fr-FR')}`);
    
    if (simulation.results) {
      console.log(`   Produits √©valu√©s: ${simulation.results.total_evaluated || 'N/A'}`);
      console.log(`   Produits √©ligibles: ${simulation.results.eligible_count || 'N/A'}`);
    }
    
    success('Donn√©es de simulation v√©rifi√©es');
    return true;
    
  } catch (err) {
    error(`Erreur v√©rification simulation: ${err.message}`);
    return false;
  }
}

// ==============================================================================
// FONCTION PRINCIPALE
// ==============================================================================

async function runTest() {
  console.log('\n' + '='.repeat(80));
  log('üß™', 'D√âMARRAGE DU TEST COMPLET DE SIMULATION', colors.bright);
  console.log('='.repeat(80) + '\n');
  
  let testsPassed = 0;
  let testsFailed = 0;
  
  try {
    // 1. Connexion
    const auth = await loginClient();
    if (!auth) {
      error('Test arr√™t√©: √©chec connexion');
      return;
    }
    testsPassed++;
    
    // 2. Cr√©ation simulation
    const simulationId = await createSimulation(auth.token, auth.databaseId);
    if (!simulationId) {
      error('Test arr√™t√©: √©chec cr√©ation simulation');
      testsFailed++;
      return;
    }
    testsPassed++;
    
    // 3. R√©cup√©ration questions
    const questions = await getQuestions(auth.token);
    if (questions.length === 0) {
      warning('Aucune question disponible');
    }
    testsPassed++;
    
    // 4. G√©n√©ration r√©ponses
    const answers = generateTestAnswers(questions);
    testsPassed++;
    
    // 5. Sauvegarde r√©ponses
    const answersSaved = await saveAnswers(auth.token, simulationId, answers);
    if (!answersSaved) {
      error('Test arr√™t√©: √©chec sauvegarde r√©ponses');
      testsFailed++;
      return;
    }
    testsPassed++;
    
    // 6. Finalisation simulation
    const completed = await completeSimulation(auth.token, simulationId);
    if (!completed) {
      error('Test arr√™t√©: √©chec finalisation');
      testsFailed++;
      return;
    }
    testsPassed++;
    
    // 7. V√©rification donn√©es simulation
    await verifySimulationData(simulationId);
    testsPassed++;
    
    // 8. V√©rification r√©sultats
    const { eligible, nonEligible } = await verifyResults(auth.databaseId, simulationId);
    if (eligible.length > 0) {
      testsPassed++;
    } else {
      warning('Aucun produit √©ligible cr√©√©');
      testsFailed++;
    }
    
  } catch (err) {
    error(`Erreur inattendue: ${err.message}`);
    console.error(err);
    testsFailed++;
  }
  
  // R√©sum√© final
  console.log('\n' + '='.repeat(80));
  log('üìä', 'R√âSUM√â DES TESTS', colors.bright);
  console.log('='.repeat(80));
  console.log(`${colors.green}‚úÖ Tests r√©ussis: ${testsPassed}${colors.reset}`);
  console.log(`${colors.red}‚ùå Tests √©chou√©s: ${testsFailed}${colors.reset}`);
  console.log('='.repeat(80) + '\n');
  
  if (testsFailed === 0) {
    success('üéâ TOUS LES TESTS SONT PASS√âS !');
  } else {
    error('‚ö†Ô∏è  CERTAINS TESTS ONT √âCHOU√â');
  }
}

// Ex√©cution
runTest()
  .then(() => {
    info('Test termin√©');
    process.exit(0);
  })
  .catch(err => {
    error(`Erreur fatale: ${err.message}`);
    console.error(err);
    process.exit(1);
  });

